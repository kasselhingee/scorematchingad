% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ADFun.R, R/ADFun_print.R
\docType{class}
\name{Rcpp_ADFun-class}
\alias{Rcpp_ADFun-class}
\alias{Rcpp_ADFun}
\alias{print,Rcpp_ADFun-method}
\alias{print,Rcpp_ADFun-method#'}
\alias{show,Rcpp_ADFun-method}
\title{A Class for CppAD Tapes}
\usage{
tape$eval(x, dyn)

tape$Jac(x, dyn)

tape$Hes(x, dyn)

tape$forward(order, x)

tape$Jacobian(x)

tape$Hessiani(x, i)

tape$Hessian0(x)

tape$Hessianw(x, w)

tape$new_dynamic(dyn)

tape$parameter(i)

tape$set_check_for_nan(bool)

tape$get_check_for_nan()

\S4method{print}{Rcpp_ADFun}(x, ...)

\S4method{show}{Rcpp_ADFun}(object)
}
\arguments{
\item{x}{An object of class \linkS4class{Rcpp_ADFun}.}

\item{...}{Passed to \code{\link[=format]{format()}}.}

\item{object}{An object of class \linkS4class{Rcpp_ADFun}.}

\item{dyn}{A vector of dynamic parameters.}

\item{q}{Differentiation order.}

\item{i}{Index of range result.}

\item{name}{An easy to read name for the tape}

\item{order}{Order of differentiation for \verb{$forward()}.}

\item{bool}{Either \code{TRUE} or \code{FALSE} to set \code{check_for_nan} behaviour using \verb{$set_check_for_nan()}.}
}
\description{
Tapes are a record of operations performed by a function. Tapes can be evaluated, differentiated, and have properties (such as domain and range dimensions). Tapes also have dynamic parameters that can be updated. This class, \code{Rcpp_ADFun} uses `reference' semantics, so that copies all point to the same object and changes modify in place (i.e. changes modify the same object).
}
\details{
\code{print()} will return some properties of the class. Technically the class name is 'Rcpp_ADFun' (so \code{inherits(x, "Rcpp_ADFun")} will return \code{TRUE}) and it is a reference class that connects to \code{CppAD} tapes in \verb{C++}. Many of the methods available for tapes in \code{CppAD} are made available here.

Tapes cannot be saved from session to session.
}
\section{Functions}{
\itemize{
\item \code{print(Rcpp_ADFun)}: Displays a summary of a \linkS4class{Rcpp_ADFun} object.

\item \code{show(Rcpp_ADFun)}: Displays a summary of a \linkS4class{Rcpp_ADFun} object and overrides the default \code{show()} method for \linkS4class{C++Object} objects from \code{\link[Rcpp:CppObject-class]{Rcpp::C++Object}}.

}}
\section{Fields}{

\describe{
\item{\code{domain}}{The number of independent variables (i.e. dimension of Euclidean domain space)}

\item{\code{eval}}{Evaluation of the function at \code{x} given new values of the dynamic parameters \code{dyn}. Has two arguments, \code{x} and \code{dyn}.}

\item{\code{xtape}}{The (numeric) vector of independent variable values used for taping.}

\item{\code{dyntape}}{The (numeric) vector of dynamic parameters used for taping.}
}}

\section{Extends}{
Extends class \linkS4class{C++Object} from the \code{Rcpp} package (\code{\link[Rcpp:CppObject-class]{Rcpp::C++Object}}), which is a \verb{reference class}.
}

\section{Introduction to CppAD Tapes}{
This package uses version 2024000.5 of the algorithmic differentiation library \code{CppAD} \insertCite{bell2023cp}{scorematchingad} to build score matching estimators.
Full help for \code{CppAD} can be found at \url{https://cppad.readthedocs.io/}.

Differentiation proceeds by \emph{taping} the basic (\emph{atomic}) operations performed on the independent variables and dynamic parameters. The atomic operations include multiplication, division, addition, sine, cosine, exponential and many more.
Example values for the variables and parameters are used to conduct this taping, so care must be taken with any conditional (e.g. if-then) operations, and \href{https://cppad.readthedocs.io/}{\code{CppAD}} has a special tool for this called \code{CondExp} (short for \verb{conditional expressions}).

The result of taping is an object of class \code{ADFun} in \code{CppAD} and is often called a \emph{tape}.
This \code{ADFun} object can be evaluated, differentiated, used for further taping (via \code{CppAD}'s \code{base2ad()}), solving differential equations and more.
The differentiation is with respect to the independent variables, however the dynamic parameters can be altered which allows for creating a new \code{ADFun} object where the dynamic parameters become independent variables (see \code{\link[=tapeSwap]{tapeSwap()}}).
For the purposes of score matching, there are also \emph{fixed} parameters, which are the elements of the model's parameter vector that are given and not estimated.
}

\section{Warning: multiple CPU}{
Each time a tape is evaluated the corresponding \verb{C++} object is altered. Parallel use of the same \code{ADFun} object thus requires care and is not tested. For now I recommend creating a new \code{ADFun} object for each CPU.
}

\section{Methods accessed via \code{$}}{

\describe{
\item{\code{new_dynamic(dyn_params)}}{Specify new values for the dynamic parameters.}
\item{\code{forward(order)}}{Perform forward mode evaluation for the specified Taylor coefficient order.}
\item{\code{Jacobian()}}{Evaluate the Jacobian of the function.}
\item{\code{Hessiani(i)}}{Evaluate the Hessian for the \code{i}-th element of the range (where \code{i = 0, 1, ...}).}
\item{\code{Hessian0()}}{Evaluate the Hessian for the first element of the range.}
\item{\code{Hessianw(weights)}}{Evaluate the Hessian for a weighted sum of the range.}
\item{\code{set_check_for_nan(check)}}{Set whether the tape should check for NaN values during computation (only effective if C++ debugging is enabled).}
\item{\code{get_check_for_nan()}}{Return whether the tape is configured to check for NaN values during computation.}
\item{\code{eval(dyn_params)}}{Evaluate the function with new dynamic parameters.}
\item{\code{Jac(dyn_params)}}{Compute the Jacobian with new dynamic parameters.}
\item{\code{Hes(dyn_params)}}{Compute the Hessian with new dynamic parameters.}
\item{\code{parameter(index)}}{Check if the \code{index}-th component of the range corresponds to a constant parameter.}
}
}

\section{Properties}{

\describe{
\item{\code{size_order}}{Number of Taylor coefficient orders, per variable and direction, currently calculated and stored.}
\item{\code{domain}}{Dimension of the domain space (i.e., length of the independent variables vector).}
\item{\code{range}}{Dimension of the range space.}
\item{\code{size_dyn_ind}}{Number of independent dynamic parameters.}
\item{\code{name}}{An optional name for the tape.}
\item{\code{xtape}}{(Read-only) The values of the independent variables used for taping.}
\item{\code{dyntape}}{(Read-only) The values of the dynamic variables used for taping.}
}
}

\examples{
tape <- tape_uld_inbuilt("dirichlet", c(0.1, 0.4, 0.5), c(-0.5, -0.4, -0.2))
# Properties
tape$domain
tape$range
tape$size_dyn_ind
tape$name
tape$xtape
tape$dyntape
tape$size_order

# Convenient evaluation
tape$eval(x = c(0.2, 0.3, 0.5), dyn = c(-0.1, -0.1, -0.5))
tape$Jac(x = c(0.2, 0.3, 0.5), dyn = c(-0.1, -0.1, -0.5))
matrix(tape$Hes(x = c(0.2, 0.3, 0.5), dyn = c(-0.1, -0.1, -0.5)), nrow = tape$domain)

# Further methods
tape$forward(order = 1, x = c(0.2, 0.3, 0.5))
tape$Jacobian(x = c(0.2, 0.3, 0.5))
tape$Hessiani(x = c(0.2, 0.3, 0.5), i = 0)
tape$Hessian0(x = c(0.2, 0.3, 0.5))
tape$Hessianw(x = c(0.2, 0.3, 0.5), w = c(2))
tape$new_dynamic(dyn = c(-0.1, -0.1, -0.5))
tape$parameter(0)
tape$set_check_for_nan(FALSE)
tape$get_check_for_nan()
}
